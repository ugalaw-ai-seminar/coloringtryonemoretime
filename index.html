<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cozy Coloring Studio</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <style>body { margin: 0; }</style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;
    
    const Icon = ({ name, size = 24 }) => {
      const iconRef = useRef(null);
      useEffect(() => {
        if (iconRef.current) {
          iconRef.current.innerHTML = '';
          const icon = lucide.createElement(lucide.icons[name]);
          icon.setAttribute('width', size);
          icon.setAttribute('height', size);
          iconRef.current.appendChild(icon);
        }
      }, [name, size]);
      return <span ref={iconRef} style={{display: 'inline-flex', verticalAlign: 'middle'}} />;
    };

    const CozyColoringApp = () => {
      const canvasRef = useRef(null);
      const colorWheelRef = useRef(null);
      const lineWorkRef = useRef(null);
      const fileInputRef = useRef(null);
      const [ctx, setCtx] = useState(null);
      const [mode, setMode] = useState('fill');
      const [currentColor, setCurrentColor] = useState('#FF6B9D');
      const [hue, setHue] = useState(340);
      const [saturation, setSaturation] = useState(100);
      const [lightness, setLightness] = useState(70);
      const [isDrawing, setIsDrawing] = useState(false);
      const [brushSize, setBrushSize] = useState(15);
      const [eraserSize, setEraserSize] = useState(20);
      const [imageData, setImageData] = useState(null);
      const [history, setHistory] = useState([]);
      const [currentImageName, setCurrentImageName] = useState('Upload a coloring page to start');
      const [isDragging, setIsDragging] = useState(false);
      
      const [apiKey, setApiKey] = useState('');
      const [showApiKeyInput, setShowApiKeyInput] = useState(false);
      const [apiKeyTemp, setApiKeyTemp] = useState('');
      
      const [colorPrompt, setColorPrompt] = useState('');
      const [suggestedColors, setSuggestedColors] = useState([]);
      const [isLoadingColors, setIsLoadingColors] = useState(false);
      const [colorError, setColorError] = useState(null);
      
      const [recentColors, setRecentColors] = useState([]);
      
      useEffect(() => {
        const savedKey = localStorage.getItem('gemini_api_key');
        if (savedKey) setApiKey(savedKey);
      }, []);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (canvas) {
          const context = canvas.getContext('2d', { willReadFrequently: true });
          setCtx(context);
          context.fillStyle = 'white';
          context.fillRect(0, 0, canvas.width, canvas.height);
          const imgData = context.getImageData(0, 0, canvas.width, canvas.height);
          setImageData(imgData);
          lineWorkRef.current = imgData;
          setHistory([imgData]);
        }
        
        const colorWheel = colorWheelRef.current;
        if (colorWheel) {
          const wheelCtx = colorWheel.getContext('2d');
          const centerX = colorWheel.width / 2, centerY = colorWheel.height / 2;
          const radius = colorWheel.width / 2 - 5;
          for (let angle = 0; angle < 360; angle++) {
            wheelCtx.beginPath();
            wheelCtx.moveTo(centerX, centerY);
            wheelCtx.arc(centerX, centerY, radius, (angle - 90) * Math.PI / 180, (angle + 1 - 90) * Math.PI / 180);
            wheelCtx.closePath();
            wheelCtx.fillStyle = `hsl(${angle}, 100%, 50%)`;
            wheelCtx.fill();
          }
          wheelCtx.beginPath();
          wheelCtx.arc(centerX, centerY, radius * 0.3, 0, Math.PI * 2);
          wheelCtx.fillStyle = 'white';
          wheelCtx.fill();
          wheelCtx.strokeStyle = '#ccc';
          wheelCtx.lineWidth = 2;
          wheelCtx.stroke();
        }
      }, []);

      const hslToHex = (h, s, l) => {
        s /= 100; l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = (n) => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
      };
      
      const rgbToHex = (r, g, b) => '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
      
      const hexToHsl = (hex) => {
        let r = parseInt(hex.slice(1, 3), 16) / 255;
        let g = parseInt(hex.slice(3, 5), 16) / 255;
        let b = parseInt(hex.slice(5, 7), 16) / 255;
        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) { h = s = 0; }
        else {
          let d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
            case g: h = ((b - r) / d + 2) / 6; break;
            case b: h = ((r - g) / d + 4) / 6; break;
          }
        }
        return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
      };

      const handleColorWheelClick = (e) => {
        const rect = colorWheelRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        const centerX = 100, centerY = 100;
        const dx = x - centerX, dy = y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius = 95;
        
        if (distance <= radius * 0.3) {
          setHue(0); setSaturation(0); setLightness(95);
          setCurrentColor(hslToHex(0, 0, 95));
        } else if (distance <= radius) {
          let angle = (Math.atan2(dy, dx) * 180 / Math.PI + 90 + 360) % 360;
          setHue(Math.round(angle)); setSaturation(100); setLightness(50);
          setCurrentColor(hslToHex(Math.round(angle), 100, 50));
        }
      };

      useEffect(() => { setCurrentColor(hslToHex(hue, saturation, lightness)); }, [hue, saturation, lightness]);

      const saveToHistory = () => {
        if (!ctx || !canvasRef.current) return;
        setHistory(prev => [...prev, ctx.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height)]);
      };

      const undo = () => {
        if (history.length <= 1) return;
        const newHistory = [...history];
        newHistory.pop();
        setHistory(newHistory);
        const prev = newHistory[newHistory.length - 1];
        if (ctx && prev) { ctx.putImageData(prev, 0, 0); setImageData(prev); }
      };

      const isBlackPixel = (data, i) => data[i] === 0 && data[i+1] === 0 && data[i+2] === 0;

      const protectLinework = (newImageData) => {
        if (!lineWorkRef.current) return newImageData;
        const linework = lineWorkRef.current.data, newData = newImageData.data;
        for (let i = 0; i < linework.length; i += 4) {
          if (isBlackPixel(linework, i)) { newData[i] = 0; newData[i+1] = 0; newData[i+2] = 0; newData[i+3] = 255; }
        }
        return newImageData;
      };

      const getColorAtPoint = (x, y) => {
        if (!ctx || !imageData) return null;
        const canvas = canvasRef.current, rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
        const cx = Math.floor((x - rect.left) * scaleX), cy = Math.floor((y - rect.top) * scaleY);
        const i = (cy * canvas.width + cx) * 4;
        return { r: imageData.data[i], g: imageData.data[i+1], b: imageData.data[i+2], a: imageData.data[i+3] };
      };

      const hexToRgb = (hex) => {
        const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return r ? { r: parseInt(r[1], 16), g: parseInt(r[2], 16), b: parseInt(r[3], 16) } : null;
      };

      const floodFill = (startX, startY, fillColor) => {
        if (!ctx || !imageData) return;
        const canvas = canvasRef.current, target = getColorAtPoint(startX, startY);
        if (!target || isBlackPixel([target.r, target.g, target.b], 0)) return;
        const fill = hexToRgb(fillColor);
        if (!fill || (target.r === fill.r && target.g === fill.g && target.b === fill.b)) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((startX - rect.left) * canvas.width / rect.width);
        const y = Math.floor((startY - rect.top) * canvas.height / rect.height);
        const newData = ctx.getImageData(0, 0, canvas.width, canvas.height), pixels = newData.data;
        const stack = [[x, y]], visited = new Set();
        const match = (i) => pixels[i] === target.r && pixels[i+1] === target.g && pixels[i+2] === target.b && pixels[i+3] === target.a;
        
        while (stack.length) {
          const [cx, cy] = stack.pop(), key = `${cx},${cy}`;
          if (visited.has(key) || cx < 0 || cx >= canvas.width || cy < 0 || cy >= canvas.height) continue;
          const i = (cy * canvas.width + cx) * 4;
          if (!match(i) || isBlackPixel(pixels, i)) continue;
          visited.add(key);
          pixels[i] = fill.r; pixels[i+1] = fill.g; pixels[i+2] = fill.b; pixels[i+3] = 255;
          stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
        }
        
        const protected_ = protectLinework(newData);
        ctx.putImageData(protected_, 0, 0);
        setImageData(protected_);
        saveToHistory();
      };
      
      const pickColor = (e) => {
        const c = getColorAtPoint(e.clientX, e.clientY);
        if (c && !(c.r === 0 && c.g === 0 && c.b === 0) && !(c.r === 255 && c.g === 255 && c.b === 255)) {
          const hex = rgbToHex(c.r, c.g, c.b);
          setCurrentColor(hex);
          const hsl = hexToHsl(hex);
          setHue(hsl.h); setSaturation(hsl.s); setLightness(hsl.l);
          setRecentColors(prev => [hex, ...prev.filter(x => x !== hex)].slice(0, 10));
        }
      };

      const handleCanvasClick = (e) => {
        if (mode === 'fill') floodFill(e.clientX, e.clientY, currentColor);
        else if (mode === 'eyedropper') { pickColor(e); setMode('fill'); }
      };

      const handleMouseDown = (e) => { if (mode === 'brush' || mode === 'eraser') { setIsDrawing(true); draw(e); } };
      const handleMouseMove = (e) => { if ((mode === 'brush' || mode === 'eraser') && isDrawing) draw(e); };
      const handleMouseUp = () => { if (isDrawing) { setIsDrawing(false); saveToHistory(); } };

      const draw = (e) => {
        if (!ctx) return;
        const canvas = canvasRef.current, rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * canvas.width / rect.width;
        const y = (e.clientY - rect.top) * canvas.height / rect.height;
        
        if (mode === 'eraser') {
          ctx.globalCompositeOperation = 'destination-out';
          ctx.beginPath(); ctx.arc(x, y, eraserSize, 0, Math.PI * 2); ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
        } else {
          ctx.fillStyle = currentColor;
          ctx.beginPath(); ctx.arc(x, y, brushSize, 0, Math.PI * 2); ctx.fill();
        }
        const newData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        ctx.putImageData(protectLinework(newData), 0, 0);
        setImageData(newData);
      };

      const resetCanvas = () => {
        if (!ctx || !lineWorkRef.current) return;
        ctx.putImageData(lineWorkRef.current, 0, 0);
        setImageData(lineWorkRef.current);
        setHistory([lineWorkRef.current]);
      };

      const downloadImage = () => {
        const link = document.createElement('a');
        link.download = `coloring-${Date.now()}.png`;
        link.href = canvasRef.current.toDataURL();
        link.click();
      };

      const handleDragOver = (e) => { e.preventDefault(); setIsDragging(true); };
      const handleDragLeave = () => setIsDragging(false);
      const handleDrop = (e) => {
        e.preventDefault(); setIsDragging(false);
        if (e.dataTransfer.files?.[0]?.type.startsWith('image/')) processImageFile(e.dataTransfer.files[0]);
      };
      
      const loadImageToCanvas = (src, name) => {
        if (!ctx) return;
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const canvas = canvasRef.current;
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
          const w = img.width * scale, h = img.height * scale;
          ctx.drawImage(img, (canvas.width - w) / 2, (canvas.height - h) / 2, w, h);
          
          const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height), p = imgData.data;
          for (let i = 0; i < p.length; i += 4) {
            const v = (p[i] + p[i+1] + p[i+2]) / 3 > 180 ? 255 : 0;
            p[i] = p[i+1] = p[i+2] = v; p[i+3] = 255;
          }
          ctx.putImageData(imgData, 0, 0);
          
          const linework = ctx.getImageData(0, 0, canvas.width, canvas.height);
          lineWorkRef.current = linework;
          setImageData(linework);
          setHistory([linework]);
          setCurrentImageName(name);
        };
        img.src = src;
      };
      
      const processImageFile = (file) => {
        const reader = new FileReader();
        reader.onload = (e) => loadImageToCanvas(e.target.result, file.name.replace(/\.[^/.]+$/, ''));
        reader.readAsDataURL(file);
      };

      const handleImageUpload = (e) => { if (e.target.files[0]) processImageFile(e.target.files[0]); };
      
      const saveApiKey = () => {
        if (apiKeyTemp.trim()) {
          localStorage.setItem('gemini_api_key', apiKeyTemp.trim());
          setApiKey(apiKeyTemp.trim());
          setShowApiKeyInput(false);
          setApiKeyTemp('');
        }
      };
      
      const clearApiKey = () => { 
        localStorage.removeItem('gemini_api_key'); 
        setApiKey(''); 
        setSuggestedColors([]); 
      };
      
      // AI Color Suggestions with Gemini
      const suggestColors = async () => {
        if (!colorPrompt.trim() || isLoadingColors) return;
        if (!apiKey) { setShowApiKeyInput(true); setColorError('Please enter your API key first'); return; }
        
        setIsLoadingColors(true);
        setColorError(null);
        
        try {
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{
                parts: [{
                  text: `Suggest 8 colors for coloring a picture of: ${colorPrompt}

Return ONLY a JSON array, no other text or markdown:
[{"name": "Sky Blue", "hex": "#87CEEB"}, {"name": "Forest Green", "hex": "#228B22"}]

Choose harmonious, vibrant colors that match the theme.`
                }]
              }]
            })
          });
          
          let data;
          try {
            data = await response.json();
          } catch (e) {
            throw new Error(`Response error: ${response.status} ${response.statusText}`);
          }
          
          if (!response.ok) {
            throw new Error(data.error?.message || data.error?.status || `Error ${response.status}`);
          }
          
          const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
          if (!text) throw new Error('Empty response - check your API key');
          
          const match = text.match(/\[[\s\S]*?\]/);
          if (match) {
            setSuggestedColors(JSON.parse(match[0]));
          } else {
            throw new Error('Invalid response format');
          }
        } catch (err) {
          console.error('Error:', err);
          if (err.name === 'TypeError' && err.message.includes('fetch')) {
            setColorError('Network error - check internet connection');
          } else {
            setColorError(err.message);
          }
        } finally {
          setIsLoadingColors(false);
        }
      };
      
      const selectColor = (hex) => {
        setCurrentColor(hex);
        const hsl = hexToHsl(hex);
        setHue(hsl.h); setSaturation(hsl.s); setLightness(hsl.l);
        setRecentColors(prev => [hex, ...prev.filter(c => c !== hex)].slice(0, 10));
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-amber-50 to-rose-50 p-4 md:p-6">
          <div className="max-w-7xl mx-auto">
            <div className="text-center mb-4">
              <h1 className="text-3xl font-bold text-amber-900 mb-1">Cozy Coloring Studio</h1>
              <p className="text-amber-700 text-sm">Relax and color beautiful designs</p>
            </div>
            
            {/* Toolbar */}
            <div className="bg-white rounded-xl shadow-lg p-3 mb-4">
              <div className="flex flex-wrap items-center gap-3 justify-center">
                <div className="flex gap-2">
                  {[['fill', 'Droplet', 'Fill'], ['brush', 'Paintbrush', 'Brush'], ['eraser', 'Eraser', 'Erase'], ['eyedropper', 'Pipette', 'Pick']].map(([m, icon, label]) => (
                    <button key={m} onClick={() => setMode(m)}
                      className={`flex items-center gap-1 px-3 py-2 rounded-lg text-sm transition-all ${
                        mode === m ? (m === 'eyedropper' ? 'bg-purple-500 text-white' : 'bg-amber-500 text-white')
                        : (m === 'eyedropper' ? 'bg-purple-50 text-purple-700 hover:bg-purple-100' : 'bg-amber-50 text-amber-700 hover:bg-amber-100')
                      }`}>
                      <Icon name={icon} size={16} /> {label}
                    </button>
                  ))}
                </div>
                {(mode === 'brush' || mode === 'eraser') && (
                  <div className="flex items-center gap-2 w-32">
                    <span className="text-xs text-amber-700">Size:</span>
                    <input type="range" min={mode === 'brush' ? 5 : 10} max={mode === 'brush' ? 50 : 80}
                      value={mode === 'brush' ? brushSize : eraserSize}
                      onChange={(e) => mode === 'brush' ? setBrushSize(+e.target.value) : setEraserSize(+e.target.value)}
                      className="flex-1 h-2" />
                    <span className="text-xs text-amber-700 w-6">{mode === 'brush' ? brushSize : eraserSize}</span>
                  </div>
                )}
              </div>
            </div>
            
            <div className="grid md:grid-cols-[1fr,300px] gap-4">
              {/* Canvas */}
              <div className={`bg-white rounded-xl shadow-lg p-3 relative ${isDragging ? 'ring-4 ring-indigo-400' : ''}`}
                onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop}>
                {isDragging && (
                  <div className="absolute inset-0 bg-indigo-100/90 rounded-xl flex items-center justify-center z-10">
                    <p className="text-xl font-semibold text-indigo-700">Drop image here</p>
                  </div>
                )}
                <div className="flex justify-between mb-2">
                  <span className="font-medium text-amber-900 text-sm truncate">{currentImageName}</span>
                  <span className="text-amber-600 text-sm">{mode === 'fill' ? 'üé®' : mode === 'brush' ? 'üñåÔ∏è' : mode === 'eraser' ? 'üßπ' : 'üíâ'}</span>
                </div>
                <canvas ref={canvasRef} width={700} height={600}
                  onClick={handleCanvasClick} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove}
                  onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
                  className="w-full border-2 border-amber-200 rounded-lg bg-white cursor-crosshair" />
                {currentImageName === 'Upload a coloring page to start' && (
                  <div className="absolute inset-0 flex items-center justify-center pointer-events-none mt-8">
                    <p className="text-amber-400">Drag & drop an image or click Upload ‚Üí</p>
                  </div>
                )}
              </div>
              
              {/* Side Panel */}
              <div className="bg-white rounded-xl shadow-lg p-3 space-y-3 overflow-y-auto max-h-[750px]">
                
                {/* Upload */}
                <div className="pb-3 border-b border-amber-100">
                  <h3 className="font-semibold text-amber-900 text-sm mb-2">üìÅ Upload Coloring Page</h3>
                  <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/*" className="hidden" />
                  <button onClick={() => fileInputRef.current?.click()}
                    className="w-full p-2 bg-indigo-500 text-white rounded-lg text-sm flex items-center justify-center gap-2 hover:bg-indigo-600">
                    <Icon name="Upload" size={16} /> Upload Image
                  </button>
                  <p className="text-xs text-amber-600 mt-2 text-center">Or drag & drop onto canvas</p>
                </div>
                
                {/* Color Picker */}
                <div className="pb-3 border-b border-amber-100">
                  <h3 className="font-semibold text-amber-900 text-sm mb-2">üé® Color Picker</h3>
                  <div className="flex items-center gap-3 justify-center">
                    <canvas ref={colorWheelRef} width={200} height={200} onClick={handleColorWheelClick}
                      className="w-16 h-16 cursor-pointer rounded-lg border" />
                    <div className="w-12 h-12 rounded-lg border-2 border-amber-300 shadow-inner" style={{ backgroundColor: currentColor }} />
                    <span className="text-xs font-mono">{currentColor}</span>
                  </div>
                  <div className="mt-2 space-y-1">
                    {[['H', hue, setHue, 360], ['S', saturation, setSaturation, 100], ['L', lightness, setLightness, 100]].map(([l, v, set, max]) => (
                      <div key={l} className="flex items-center gap-2">
                        <span className="text-xs w-4">{l}</span>
                        <input type="range" min="0" max={max} value={v} onChange={(e) => set(+e.target.value)} className="flex-1 h-1" />
                        <span className="text-xs w-8">{v}</span>
                      </div>
                    ))}
                  </div>
                </div>
                
                {/* Recent Colors */}
                {recentColors.length > 0 && (
                  <div className="pb-3 border-b border-amber-100">
                    <h3 className="font-semibold text-amber-900 text-sm mb-2">Recent Colors</h3>
                    <div className="flex flex-wrap gap-1">
                      {recentColors.map((c, i) => (
                        <button key={i} onClick={() => selectColor(c)} style={{ backgroundColor: c }}
                          className="w-7 h-7 rounded-lg border border-amber-300 hover:scale-110 transition-transform" />
                      ))}
                    </div>
                  </div>
                )}
                
                {/* AI Color Suggestions */}
                <div className="pb-3 border-b border-amber-100">
                  <div className="flex justify-between items-center mb-2">
                    <h3 className="font-semibold text-amber-900 text-sm">‚ú® AI Color Suggestions</h3>
                    <button onClick={() => setShowApiKeyInput(!showApiKeyInput)} className="text-xs text-purple-600">
                      {apiKey ? 'üîë Key Set' : '‚öôÔ∏è Set Key'}
                    </button>
                  </div>
                  
                  {showApiKeyInput && (
                    <div className="mb-3 p-2 bg-purple-50 rounded-lg">
                      <input type="password" value={apiKeyTemp} onChange={(e) => setApiKeyTemp(e.target.value)}
                        placeholder="Paste your Gemini API key..." className="w-full p-2 border rounded text-xs" />
                      <div className="flex gap-2 mt-2">
                        <button onClick={saveApiKey} className="flex-1 bg-purple-500 text-white text-xs p-1.5 rounded">Save</button>
                        {apiKey && <button onClick={clearApiKey} className="bg-red-100 text-red-600 text-xs p-1.5 rounded">Clear</button>}
                      </div>
                      <a href="https://aistudio.google.com/app/apikey" target="_blank" className="text-xs text-purple-500 underline mt-1 block">Get free API key ‚Üí</a>
                    </div>
                  )}
                  
                  <input value={colorPrompt} onChange={(e) => setColorPrompt(e.target.value)}
                    placeholder="Describe your image (e.g., ocean sunset)"
                    className="w-full p-2 border rounded-lg text-sm"
                    onKeyPress={(e) => e.key === 'Enter' && suggestColors()} />
                  <button onClick={suggestColors} disabled={!colorPrompt.trim() || isLoadingColors}
                    className={`w-full mt-2 p-2 rounded-lg text-sm flex items-center justify-center gap-2 ${
                      !colorPrompt.trim() || isLoadingColors ? 'bg-gray-200 text-gray-400' : 'bg-gradient-to-r from-purple-500 to-pink-500 text-white hover:from-purple-600 hover:to-pink-600'
                    }`}>
                    <Icon name="Sparkles" size={16} /> {isLoadingColors ? 'Getting colors...' : 'Suggest Colors'}
                  </button>
                  {colorError && <p className="text-red-500 text-xs mt-1">{colorError}</p>}
                  
                  {suggestedColors.length > 0 && (
                    <div className="mt-3 grid grid-cols-4 gap-2">
                      {suggestedColors.map((c, i) => (
                        <button key={i} onClick={() => selectColor(c.hex)} title={c.name}
                          className="flex flex-col items-center p-1 rounded hover:bg-amber-50">
                          <div className="w-10 h-10 rounded-lg border-2 border-amber-300 hover:scale-105 transition-transform" style={{ backgroundColor: c.hex }} />
                          <span className="text-xs text-amber-600 mt-1 truncate w-full text-center">{c.name.split(' ')[0]}</span>
                        </button>
                      ))}
                    </div>
                  )}
                </div>
                
                {/* Actions */}
                <div className="space-y-2">
                  <button onClick={undo} disabled={history.length <= 1}
                    className={`w-full p-2 rounded-lg text-sm flex items-center justify-center gap-2 ${
                      history.length <= 1 ? 'bg-gray-200 text-gray-400' : 'bg-blue-500 text-white hover:bg-blue-600'
                    }`}><Icon name="Undo2" size={16} /> Undo ({history.length - 1})</button>
                  <button onClick={resetCanvas} className="w-full p-2 bg-amber-500 text-white rounded-lg text-sm flex items-center justify-center gap-2 hover:bg-amber-600">
                    <Icon name="RotateCcw" size={16} /> Reset Colors</button>
                  <button onClick={downloadImage} className="w-full p-2 bg-emerald-500 text-white rounded-lg text-sm flex items-center justify-center gap-2 hover:bg-emerald-600">
                    <Icon name="Download" size={16} /> Download</button>
                </div>
                
                <div className="text-xs text-amber-600 text-center pt-2">
                  <strong>Fill:</strong> Click ‚Ä¢ <strong>Brush:</strong> Paint ‚Ä¢ <strong>Erase:</strong> Remove ‚Ä¢ <strong>Pick:</strong> Sample
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<CozyColoringApp />);
  </script>
</body>
</html>
