<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cozy Coloring Studio - Full Pro Tools</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <style>
    body { margin: 0; background-color: #fffaf5; font-family: sans-serif; }
    canvas { border-radius: 16px; cursor: crosshair; touch-action: none; background: white; image-rendering: auto; }
    input[type="range"] { accent-color: #f59e0b; }
    .tool-btn { transition: all 0.2s; }
    .tool-btn.active { background-color: #f59e0b; color: white; transform: scale(1.05); }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;
    
    const Icon = ({ name, size = 20, className = "" }) => {
      const iconRef = useRef(null);
      useEffect(() => {
        if (iconRef.current && lucide.icons[name]) {
          iconRef.current.innerHTML = '';
          const icon = lucide.createElement(lucide.icons[name]);
          icon.setAttribute('width', size);
          icon.setAttribute('height', size);
          iconRef.current.appendChild(icon);
        }
      }, [name, size]);
      return <span ref={iconRef} className={className} style={{display: 'inline-flex', verticalAlign: 'middle'}} />;
    };

    const CozyApp = () => {
      const canvasRef = useRef(null);
      const colorWheelRef = useRef(null);
      const lineWorkRef = useRef(null);
      
      const [ctx, setCtx] = useState(null);
      const [mode, setMode] = useState('fill');
      const [currentColor, setCurrentColor] = useState('#FF6B9D');
      const [isDrawing, setIsDrawing] = useState(false);
      
      // Brush Settings
      const [brushSize, setBrushSize] = useState(15);
      const [eraserSize, setEraserSize] = useState(20);
      const [history, setHistory] = useState([]);
      
      // HSL States
      const [hue, setHue] = useState(340);
      const [sat, setSat] = useState(100);
      const [light, setLight] = useState(70);

      // AI States
      const [apiKey, setApiKey] = useState(localStorage.getItem('gemini_api_key') || '');
      const [palettePrompt, setPalettePrompt] = useState('');
      const [suggestedColors, setSuggestedColors] = useState(['#FF6B9D', '#4ECDC4', '#FFD93D', '#1A535C', '#F7FFF7']);
      const [isAiLoading, setIsAiLoading] = useState(false);

      useEffect(() => {
        const canvas = canvasRef.current;
        const context = canvas.getContext('2d', { willReadFrequently: true });
        setCtx(context);
        
        context.fillStyle = 'white';
        context.fillRect(0, 0, 800, 800);
        
        // Default coloring border
        context.strokeStyle = 'black';
        context.lineWidth = 8;
        context.lineJoin = 'round';
        context.strokeRect(50, 50, 700, 700);
        context.beginPath();
        context.arc(400, 400, 200, 0, Math.PI * 2);
        context.stroke();

        const initialData = context.getImageData(0, 0, 800, 800);
        lineWorkRef.current = initialData;
        setHistory([initialData]);
        drawColorWheel();
      }, []);

      const drawColorWheel = () => {
        const wheel = colorWheelRef.current;
        const wCtx = wheel.getContext('2d');
        const cx = 75, cy = 75, r = 70;
        for (let a = 0; a < 360; a++) {
          const start = (a - 90) * Math.PI / 180;
          const end = (a - 89) * Math.PI / 180;
          wCtx.beginPath();
          wCtx.moveTo(cx, cy);
          wCtx.arc(cx, cy, r, start, end);
          wCtx.fillStyle = `hsl(${a}, 100%, 50%)`;
          wCtx.fill();
        }
      };

      const handleWheelClick = (e) => {
        const rect = colorWheelRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left - 75, y = e.clientY - rect.top - 75;
        let angle = Math.atan2(y, x) * 180 / Math.PI + 90;
        if (angle < 0) angle += 360;
        setHue(Math.round(angle));
        updateColorFromHSL(Math.round(angle), sat, light);
      };

      const updateColorFromHSL = (h, s, l) => {
        const hex = `hsl(${h}, ${s}%, ${l}%)`;
        const temp = document.createElement("div");
        temp.style.color = hex;
        document.body.appendChild(temp);
        const rgb = window.getComputedStyle(temp).color.match(/\d+/g);
        const hexVal = "#" + rgb.map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
        document.body.removeChild(temp);
        setCurrentColor(hexVal.toUpperCase());
      };

      const saveToHistory = () => {
        setHistory(prev => [...prev.slice(-19), ctx.getImageData(0, 0, 800, 800)]);
      };

      const undo = () => {
        if (history.length <= 1) return;
        const newHistory = [...history];
        newHistory.pop();
        ctx.putImageData(newHistory[newHistory.length - 1], 0, 0);
        setHistory(newHistory);
      };

      const fetchPalette = async () => {
        if (!palettePrompt.trim() || !apiKey) return;
        setIsAiLoading(true);
        try {
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{ parts: [{ text: `Provide 6 hex codes for a coloring palette: "${palettePrompt}". Return ONLY a JSON array.` }] }],
              generationConfig: { response_mime_type: "application/json" }
            })
          });
          const data = await response.json();
          const colors = JSON.parse(data.candidates[0].content.parts[0].text);
          setSuggestedColors(colors);
        } catch (e) { alert("AI Error: Check key or prompt."); }
        setIsAiLoading(false);
      };

      const handleCanvasAction = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (800 / rect.width);
        const y = (e.clientY - rect.top) * (800 / rect.height);

        if (mode === 'fill') floodFill(Math.floor(x), Math.floor(y));
        if (mode === 'picker') {
          const pixel = ctx.getImageData(x, y, 1, 1).data;
          const hex = "#" + [pixel[0], pixel[1], pixel[2]].map(x => x.toString(16).padStart(2, '0')).join('');
          setCurrentColor(hex.toUpperCase());
          setMode('brush');
        }
      };

      const floodFill = (x, y) => {
        const img = ctx.getImageData(0, 0, 800, 800);
        const data = img.data;
        const targetIdx = (y * 800 + x) * 4;
        const [tr, tg, tb] = [data[targetIdx], data[targetIdx+1], data[targetIdx+2]];
        if (tr < 50 && tg < 50 && tb < 50) return;

        const fill = {
          r: parseInt(currentColor.slice(1,3), 16),
          g: parseInt(currentColor.slice(3,5), 16),
          b: parseInt(currentColor.slice(5,7), 16)
        };
        if (tr === fill.r && tg === fill.g && tb === fill.b) return;

        const stack = [[x, y]];
        while (stack.length) {
          const [cx, cy] = stack.pop();
          const idx = (cy * 800 + cx) * 4;
          if (cx < 0 || cx >= 800 || cy < 0 || cy >= 800) continue;
          if (data[idx] === tr && data[idx+1] === tg && data[idx+2] === tb) {
            data[idx] = fill.r; data[idx+1] = fill.g; data[idx+2] = fill.b; data[idx+3] = 255;
            stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
          }
        }
        ctx.putImageData(img, 0, 0);
        saveToHistory();
      };

      const draw = (e) => {
        if (!isDrawing || mode === 'fill' || mode === 'picker') return;
        const rect = canvasRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (800 / rect.width);
        const y = (e.clientY - rect.top) * (800 / rect.height);
        
        ctx.beginPath();
        ctx.arc(x, y, mode === 'brush' ? brushSize : eraserSize, 0, Math.PI * 2);
        ctx.fillStyle = mode === 'brush' ? currentColor : 'white';
        ctx.fill();
        
        // Protect Linework
        const current = ctx.getImageData(0,0,800,800);
        for(let i=0; i<current.data.length; i+=4) {
          if (lineWorkRef.current.data[i] < 50) {
            current.data[i] = 0; current.data[i+1] = 0; current.data[i+2] = 0;
          }
        }
        ctx.putImageData(current, 0, 0);
      };

      return (
        <div className="min-h-screen p-4 md:p-8 flex flex-col items-center">
          <div className="max-w-7xl w-full grid lg:grid-cols-[280px,1fr,320px] gap-6">
            
            {/* Left: Tools & Brush */}
            <div className="bg-white p-6 rounded-3xl shadow-lg border border-orange-100 space-y-8">
              <div>
                <h3 className="text-xs font-bold text-gray-400 uppercase tracking-widest mb-4">Main Tools</h3>
                <div className="grid grid-cols-2 gap-3">
                  <button onClick={() => setMode('fill')} className={`tool-btn p-4 rounded-2xl border flex flex-col items-center gap-2 ${mode === 'fill' ? 'active shadow-lg' : 'bg-orange-50 border-orange-100'}`}>
                    <Icon name="Droplet" /><span className="text-[10px] font-bold">FILL</span>
                  </button>
                  <button onClick={() => setMode('brush')} className={`tool-btn p-4 rounded-2xl border flex flex-col items-center gap-2 ${mode === 'brush' ? 'active shadow-lg' : 'bg-orange-50 border-orange-100'}`}>
                    <Icon name="Paintbrush" /><span className="text-[10px] font-bold">BRUSH</span>
                  </button>
                  <button onClick={() => setMode('eraser')} className={`tool-btn p-4 rounded-2xl border flex flex-col items-center gap-2 ${mode === 'eraser' ? 'active shadow-lg' : 'bg-orange-50 border-orange-100'}`}>
                    <Icon name="Eraser" /><span className="text-[10px] font-bold">ERASE</span>
                  </button>
                  <button onClick={() => setMode('picker')} className={`tool-btn p-4 rounded-2xl border flex flex-col items-center gap-2 ${mode === 'picker' ? 'active shadow-lg' : 'bg-orange-50 border-orange-100'}`}>
                    <Icon name="Pipette" /><span className="text-[10px] font-bold">PICK</span>
                  </button>
                </div>
              </div>

              <div className="space-y-4">
                <h3 className="text-xs font-bold text-gray-400 uppercase tracking-widest">Brush Size</h3>
                <input type="range" min="2" max="50" value={brushSize} onChange={(e) => setBrushSize(e.target.value)} className="w-full h-2 bg-orange-100 rounded-lg appearance-none" />
                <h3 className="text-xs font-bold text-gray-400 uppercase tracking-widest">Eraser Size</h3>
                <input type="range" min="5" max="100" value={eraserSize} onChange={(e) => setEraserSize(e.target.value)} className="w-full h-2 bg-orange-100 rounded-lg appearance-none" />
              </div>
            </div>

            {/* Middle: Canvas */}
            <div className="space-y-4">
              <div className="bg-white p-2 rounded-3xl shadow-2xl border-4 border-orange-200 aspect-square overflow-hidden relative">
                <canvas ref={canvasRef} width={800} height={800} className="w-full h-full" 
                  onMouseDown={() => setIsDrawing(true)}
                  onMouseMove={draw}
                  onMouseUp={() => { if(isDrawing) { setIsDrawing(false); saveToHistory(); }}}
                  onClick={handleCanvasAction}
                />
              </div>
              <div className="flex justify-center gap-4">
                <button onClick={undo} className="px-6 py-2 bg-white border border-gray-200 rounded-xl font-bold flex items-center gap-2 hover:bg-gray-50 shadow-sm"><Icon name="Undo2" size={16}/> Undo</button>
                <button onClick={() => { ctx.fillStyle='white'; ctx.fillRect(0,0,800,800); ctx.putImageData(lineWorkRef.current,0,0); saveToHistory(); }} className="px-6 py-2 bg-white border border-red-100 text-red-500 rounded-xl font-bold hover:bg-red-50 shadow-sm">Reset Colors</button>
              </div>
            </div>

            {/* Right: AI & Color Wheel */}
            <div className="space-y-6">
              <div className="bg-white p-6 rounded-3xl shadow-lg border-2 border-purple-100">
                <div className="flex items-center gap-2 mb-4 text-purple-700 font-bold italic"><Icon name="Sparkles" /> AI Palette Agent</div>
                <input type="password" placeholder="Gemini API Key" className="w-full p-2 mb-3 border rounded-xl text-xs" value={apiKey} onChange={(e) => { setApiKey(e.target.value); localStorage.setItem('gemini_api_key', e.target.value); }} />
                <textarea className="w-full p-3 border rounded-2xl text-xs h-20 mb-3 focus:border-purple-300 outline-none" placeholder="Theme? (e.g. Autumn Forest)" value={palettePrompt} onChange={(e) => setPalettePrompt(e.target.value)} />
                <button onClick={fetchPalette} disabled={isAiLoading} className="w-full py-2 bg-purple-600 text-white rounded-xl text-sm font-bold shadow-md hover:bg-purple-700 transition">{isAiLoading ? "Loading..." : "Generate Colors"}</button>
                <div className="grid grid-cols-3 gap-2 mt-4">
                  {suggestedColors.map((c, i) => (
                    <button key={i} onClick={() => { setCurrentColor(c); const temp = document.createElement("div"); temp.style.color = c; document.body.appendChild(temp); const rgb = window.getComputedStyle(temp).color.match(/\d+/g); setHue(340); document.body.removeChild(temp); }} className="aspect-square rounded-xl border-2 border-white shadow-sm" style={{backgroundColor: c}} />
                  ))}
                </div>
              </div>

              <div className="bg-white p-6 rounded-3xl shadow-lg border border-orange-100 flex flex-col items-center">
                <canvas ref={colorWheelRef} width={150} height={150} onClick={handleWheelClick} className="cursor-crosshair mb-4" />
                <div className="w-full space-y-3">
                   <div className="flex justify-between items-center"><span className="text-[10px] font-bold text-gray-400">SATURATION</span><span className="text-[10px]">{sat}%</span></div>
                   <input type="range" value={sat} onChange={(e) => { setSat(e.target.value); updateColorFromHSL(hue, e.target.value, light); }} className="w-full h-1.5" />
                   <div className="flex justify-between items-center"><span className="text-[10px] font-bold text-gray-400">LIGHTNESS</span><span className="text-[10px]">{light}%</span></div>
                   <input type="range" value={light} onChange={(e) => { setLight(e.target.value); updateColorFromHSL(hue, sat, e.target.value); }} className="w-full h-1.5" />
                </div>
                <div className="mt-4 flex items-center gap-3 w-full">
                  <div className="w-12 h-12 rounded-2xl border-4 border-white shadow-md shrink-0" style={{backgroundColor: currentColor}} />
                  <div className="font-mono font-bold text-lg text-gray-600">{currentColor}</div>
                </div>
              </div>
            </div>

          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CozyApp />);
  </script>
</body>
</html>
