<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cozy Coloring Studio</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <style>
    body { margin: 0; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect } = React;
    
    const Icon = ({ name, size = 24, className = "" }) => {
      const iconRef = useRef(null);
      useEffect(() => {
        if (iconRef.current) {
          iconRef.current.innerHTML = '';
          const icon = lucide.createElement(lucide.icons[name]);
          icon.setAttribute('width', size);
          icon.setAttribute('height', size);
          iconRef.current.appendChild(icon);
        }
      }, [name, size]);
      return <span ref={iconRef} className={className} style={{display: 'inline-flex', verticalAlign: 'middle'}} />;
    };

    const CozyColoringApp = () => {
      const canvasRef = useRef(null);
      const colorWheelRef = useRef(null);
      const lineWorkRef = useRef(null);
      const fileInputRef = useRef(null);
      const [ctx, setCtx] = useState(null);
      const [mode, setMode] = useState('fill');
      const [currentColor, setCurrentColor] = useState('#FF6B9D');
      const [hue, setHue] = useState(340);
      const [saturation, setSaturation] = useState(100);
      const [lightness, setLightness] = useState(70);
      const [isDrawing, setIsDrawing] = useState(false);
      const [brushSize, setBrushSize] = useState(15);
      const [eraserSize, setEraserSize] = useState(20);
      const [imageData, setImageData] = useState(null);
      const [history, setHistory] = useState([]);
      const [currentImageName, setCurrentImageName] = useState('Generate or upload a coloring page');
      const [isDragging, setIsDragging] = useState(false);
      
      // API Key (Gemini)
      const [apiKey, setApiKey] = useState('');
      const [showApiKeyInput, setShowApiKeyInput] = useState(false);
      const [apiKeyTemp, setApiKeyTemp] = useState('');
      
      // AI Image Generation
      const [imagePrompt, setImagePrompt] = useState('');
      const [isGeneratingImage, setIsGeneratingImage] = useState(false);
      const [imageError, setImageError] = useState(null);
      
      // AI Color Suggestions
      const [colorPrompt, setColorPrompt] = useState('');
      const [suggestedColors, setSuggestedColors] = useState([]);
      const [isLoadingColors, setIsLoadingColors] = useState(false);
      const [colorError, setColorError] = useState(null);
      
      // Recent colors
      const [recentColors, setRecentColors] = useState([]);
      
      useEffect(() => {
        const savedKey = localStorage.getItem('gemini_api_key');
        if (savedKey) setApiKey(savedKey);
      }, []);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (canvas) {
          const context = canvas.getContext('2d', { willReadFrequently: true });
          setCtx(context);
          context.fillStyle = 'white';
          context.fillRect(0, 0, canvas.width, canvas.height);
          const imgData = context.getImageData(0, 0, canvas.width, canvas.height);
          setImageData(imgData);
          lineWorkRef.current = imgData;
          setHistory([imgData]);
        }
        
        const colorWheel = colorWheelRef.current;
        if (colorWheel) {
          const wheelCtx = colorWheel.getContext('2d');
          const centerX = colorWheel.width / 2;
          const centerY = colorWheel.height / 2;
          const radius = colorWheel.width / 2 - 5;
          
          for (let angle = 0; angle < 360; angle++) {
            const startAngle = (angle - 90) * Math.PI / 180;
            const endAngle = (angle + 1 - 90) * Math.PI / 180;
            wheelCtx.beginPath();
            wheelCtx.moveTo(centerX, centerY);
            wheelCtx.arc(centerX, centerY, radius, startAngle, endAngle);
            wheelCtx.closePath();
            wheelCtx.fillStyle = `hsl(${angle}, 100%, 50%)`;
            wheelCtx.fill();
          }
          
          wheelCtx.beginPath();
          wheelCtx.arc(centerX, centerY, radius * 0.3, 0, Math.PI * 2);
          wheelCtx.fillStyle = 'white';
          wheelCtx.fill();
          wheelCtx.strokeStyle = '#ccc';
          wheelCtx.lineWidth = 2;
          wheelCtx.stroke();
        }
      }, []);

      const hslToHex = (h, s, l) => {
        s /= 100; l /= 100;
        const a = s * Math.min(l, 1 - l);
        const f = (n) => {
          const k = (n + h / 30) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
      };
      
      const rgbToHex = (r, g, b) => '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
      
      const hexToHsl = (hex) => {
        let r = parseInt(hex.slice(1, 3), 16) / 255;
        let g = parseInt(hex.slice(3, 5), 16) / 255;
        let b = parseInt(hex.slice(5, 7), 16) / 255;
        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) { h = s = 0; }
        else {
          let d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
            case g: h = ((b - r) / d + 2) / 6; break;
            case b: h = ((r - g) / d + 4) / 6; break;
          }
        }
        return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
      };

      const handleColorWheelClick = (e) => {
        const colorWheel = colorWheelRef.current;
        const rect = colorWheel.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        const centerX = colorWheel.width / 2, centerY = colorWheel.height / 2;
        const dx = x - centerX, dy = y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius = colorWheel.width / 2 - 5;
        
        if (distance <= radius * 0.3) {
          setHue(0); setSaturation(0); setLightness(95);
          setCurrentColor(hslToHex(0, 0, 95));
        } else if (distance <= radius) {
          let angle = Math.atan2(dy, dx) * 180 / Math.PI;
          angle = (angle + 90 + 360) % 360;
          setHue(Math.round(angle)); setSaturation(100); setLightness(50);
          setCurrentColor(hslToHex(Math.round(angle), 100, 50));
        }
      };

      useEffect(() => {
        setCurrentColor(hslToHex(hue, saturation, lightness));
      }, [hue, saturation, lightness]);

      const saveToHistory = () => {
        if (!ctx || !canvasRef.current) return;
        const imgData = ctx.getImageData(0, 0, canvasRef.current.width, canvasRef.current.height);
        setHistory(prev => [...prev, imgData]);
      };

      const undo = () => {
        if (history.length <= 1) return;
        const newHistory = [...history];
        newHistory.pop();
        setHistory(newHistory);
        const previousState = newHistory[newHistory.length - 1];
        if (ctx && previousState) {
          ctx.putImageData(previousState, 0, 0);
          setImageData(previousState);
        }
      };

      const isBlackPixel = (data, index) => data[index] === 0 && data[index + 1] === 0 && data[index + 2] === 0;

      const protectLinework = (newImageData) => {
        if (!lineWorkRef.current) return newImageData;
        const linework = lineWorkRef.current.data;
        const newData = newImageData.data;
        for (let i = 0; i < linework.length; i += 4) {
          if (isBlackPixel(linework, i)) {
            newData[i] = 0; newData[i + 1] = 0; newData[i + 2] = 0; newData[i + 3] = 255;
          }
        }
        return newImageData;
      };

      const getColorAtPoint = (x, y) => {
        if (!ctx || !imageData) return null;
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
        const canvasX = Math.floor((x - rect.left) * scaleX);
        const canvasY = Math.floor((y - rect.top) * scaleY);
        const index = (canvasY * canvas.width + canvasX) * 4;
        return { r: imageData.data[index], g: imageData.data[index + 1], b: imageData.data[index + 2], a: imageData.data[index + 3] };
      };

      const hexToRgb = (hex) => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
      };

      const floodFill = (startX, startY, fillColor) => {
        if (!ctx || !imageData) return;
        const canvas = canvasRef.current;
        const targetColor = getColorAtPoint(startX, startY);
        if (!targetColor || (targetColor.r === 0 && targetColor.g === 0 && targetColor.b === 0)) return;
        const fillRgb = hexToRgb(fillColor);
        if (!fillRgb || (targetColor.r === fillRgb.r && targetColor.g === fillRgb.g && targetColor.b === fillRgb.b)) return;
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
        const x = Math.floor((startX - rect.left) * scaleX), y = Math.floor((startY - rect.top) * scaleY);
        const newImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = newImageData.data;
        const stack = [[x, y]];
        const visited = new Set();
        const colorMatch = (index) => pixels[index] === targetColor.r && pixels[index + 1] === targetColor.g && pixels[index + 2] === targetColor.b && pixels[index + 3] === targetColor.a;
        
        while (stack.length > 0) {
          const [cx, cy] = stack.pop();
          const key = `${cx},${cy}`;
          if (visited.has(key) || cx < 0 || cx >= canvas.width || cy < 0 || cy >= canvas.height) continue;
          const index = (cy * canvas.width + cx) * 4;
          if (!colorMatch(index) || isBlackPixel(pixels, index)) continue;
          visited.add(key);
          pixels[index] = fillRgb.r; pixels[index + 1] = fillRgb.g; pixels[index + 2] = fillRgb.b; pixels[index + 3] = 255;
          stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
        }
        
        const protectedData = protectLinework(newImageData);
        ctx.putImageData(protectedData, 0, 0);
        setImageData(protectedData);
        saveToHistory();
      };
      
      const pickColorFromCanvas = (e) => {
        const color = getColorAtPoint(e.clientX, e.clientY);
        if (color && !(color.r === 0 && color.g === 0 && color.b === 0) && !(color.r === 255 && color.g === 255 && color.b === 255)) {
          const hex = rgbToHex(color.r, color.g, color.b);
          setCurrentColor(hex);
          const hsl = hexToHsl(hex);
          setHue(hsl.h); setSaturation(hsl.s); setLightness(hsl.l);
          setRecentColors(prev => {
            const filtered = prev.filter(c => c !== hex);
            return [hex, ...filtered].slice(0, 10);
          });
        }
      };

      const handleCanvasClick = (e) => {
        if (mode === 'fill') floodFill(e.clientX, e.clientY, currentColor);
        else if (mode === 'eyedropper') { pickColorFromCanvas(e); setMode('fill'); }
      };

      const handleMouseDown = (e) => { if (mode === 'brush' || mode === 'eraser') { setIsDrawing(true); draw(e); } };
      const handleMouseMove = (e) => { if ((mode === 'brush' || mode === 'eraser') && isDrawing) draw(e); };
      const handleMouseUp = () => { if (isDrawing) { setIsDrawing(false); saveToHistory(); } };

      const draw = (e) => {
        if (!ctx) return;
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX, y = (e.clientY - rect.top) * scaleY;
        
        if (mode === 'eraser') {
          ctx.globalCompositeOperation = 'destination-out';
          ctx.fillStyle = 'rgba(0,0,0,1)';
          ctx.beginPath(); ctx.arc(x, y, eraserSize, 0, Math.PI * 2); ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
        } else {
          ctx.fillStyle = currentColor;
          ctx.beginPath(); ctx.arc(x, y, brushSize, 0, Math.PI * 2); ctx.fill();
        }
        const newData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const protectedData = protectLinework(newData);
        ctx.putImageData(protectedData, 0, 0);
        setImageData(protectedData);
      };

      const resetCanvas = () => {
        if (!ctx || !lineWorkRef.current || !canvasRef.current) return;
        ctx.putImageData(lineWorkRef.current, 0, 0);
        setImageData(lineWorkRef.current);
        setHistory([lineWorkRef.current]);
      };

      const downloadImage = () => {
        const link = document.createElement('a');
        link.download = `cozy-coloring-${Date.now()}.png`;
        link.href = canvasRef.current.toDataURL();
        link.click();
      };

      const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(true); };
      const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); };
      const handleDrop = (e) => {
        e.preventDefault(); e.stopPropagation(); setIsDragging(false);
        const files = e.dataTransfer.files;
        if (files?.[0]?.type.startsWith('image/')) processImageFile(files[0]);
      };
      
      const loadImageToCanvas = (imageSource, name, convertToLineart = true) => {
        if (!ctx || !canvasRef.current) return;
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const canvas = canvasRef.current;
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
          const drawWidth = img.width * scale, drawHeight = img.height * scale;
          const x = (canvas.width - drawWidth) / 2, y = (canvas.height - drawHeight) / 2;
          ctx.drawImage(img, x, y, drawWidth, drawHeight);
          
          if (convertToLineart) {
            const imgDataObj = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imgDataObj.data;
            for (let i = 0; i < pixels.length; i += 4) {
              const avg = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
              const val = avg > 180 ? 255 : 0;
              pixels[i] = val; pixels[i + 1] = val; pixels[i + 2] = val; pixels[i + 3] = 255;
            }
            ctx.putImageData(imgDataObj, 0, 0);
          }
          
          const linework = ctx.getImageData(0, 0, canvas.width, canvas.height);
          lineWorkRef.current = linework;
          setImageData(linework);
          setHistory([linework]);
          setCurrentImageName(name);
        };
        img.onerror = () => {
          setImageError('Failed to load image');
        };
        img.src = imageSource;
      };
      
      const processImageFile = (file) => {
        const reader = new FileReader();
        reader.onload = (e) => loadImageToCanvas(e.target.result, file.name.replace(/\.[^/.]+$/, ''));
        reader.readAsDataURL(file);
      };

      const handleImageUpload = (e) => { if (e.target.files[0]) processImageFile(e.target.files[0]); };
      
      const saveApiKey = () => {
        if (apiKeyTemp.trim()) {
          localStorage.setItem('gemini_api_key', apiKeyTemp.trim());
          setApiKey(apiKeyTemp.trim());
          setShowApiKeyInput(false);
          setApiKeyTemp('');
        }
      };
      
      const clearApiKey = () => { 
        localStorage.removeItem('gemini_api_key'); 
        setApiKey(''); 
        setSuggestedColors([]); 
      };
      
      // Generate coloring page with Gemini Imagen
      const generateColoringPage = async () => {
        if (!imagePrompt.trim() || isGeneratingImage) return;
        if (!apiKey) { 
          setShowApiKeyInput(true); 
          setImageError('Please enter your Gemini API key first'); 
          return; 
        }
        
        setIsGeneratingImage(true);
        setImageError(null);
        
        try {
          // Use Gemini's Imagen 3 model for image generation
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              instances: [
                {
                  prompt: `Black and white coloring book page, clean line art illustration of ${imagePrompt}. Simple outlines only, no shading, no gray tones, no fills. White background with black lines. Suitable for children to color. Clear distinct areas to color in.`
                }
              ],
              parameters: {
                sampleCount: 1,
                aspectRatio: "4:3",
                outputOptions: {
                  mimeType: "image/png"
                }
              }
            })
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || `API error: ${response.status}`);
          }
          
          const data = await response.json();
          
          if (data.predictions && data.predictions[0]?.bytesBase64Encoded) {
            const imageBase64 = data.predictions[0].bytesBase64Encoded;
            loadImageToCanvas(`data:image/png;base64,${imageBase64}`, imagePrompt, true);
            setImagePrompt('');
          } else {
            throw new Error('No image data in response');
          }
        } catch (err) {
          console.error('Image generation error:', err);
          setImageError(err.message);
          if (err.message.includes('API key') || err.message.includes('403') || err.message.includes('401')) {
            setShowApiKeyInput(true);
          }
        } finally {
          setIsGeneratingImage(false);
        }
      };
      
      // AI Color Suggestions with Gemini
      const suggestColors = async () => {
        if (!colorPrompt.trim() || isLoadingColors) return;
        if (!apiKey) { 
          setShowApiKeyInput(true); 
          setColorError('Please enter your Gemini API key first'); 
          return; 
        }
        
        setIsLoadingColors(true);
        setColorError(null);
        
        try {
          const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              contents: [{
                parts: [{
                  text: `I'm coloring a picture of: ${colorPrompt}

Suggest 8 colors that would be perfect for coloring this image. Return ONLY a JSON array with no other text:
[{"name": "Sky Blue", "hex": "#87CEEB"}, {"name": "Forest Green", "hex": "#228B22"}]

Choose harmonious colors that match the theme. Include a mix of main colors and accent colors.`
                }]
              }]
            })
          });
          
          if (!response.ok) {
            const err = await response.json();
            throw new Error(err.error?.message || 'API request failed');
          }
          
          const data = await response.json();
          const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
          const jsonMatch = text.match(/\[[\s\S]*?\]/);
          if (jsonMatch) {
            setSuggestedColors(JSON.parse(jsonMatch[0]));
          } else {
            throw new Error('Could not parse colors from response');
          }
        } catch (err) {
          console.error('Color suggestion error:', err);
          setColorError(err.message);
          if (err.message.includes('API key') || err.message.includes('403')) {
            setShowApiKeyInput(true);
          }
        } finally {
          setIsLoadingColors(false);
        }
      };
      
      const selectColor = (hex) => {
        setCurrentColor(hex);
        const hsl = hexToHsl(hex);
        setHue(hsl.h); setSaturation(hsl.s); setLightness(hsl.l);
        setRecentColors(prev => [hex, ...prev.filter(c => c !== hex)].slice(0, 10));
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-amber-50 to-rose-50 p-4 md:p-8">
          <div className="max-w-7xl mx-auto">
            <div className="text-center mb-6">
              <h1 className="text-3xl md:text-4xl font-bold text-amber-900 mb-2">Cozy Coloring Studio</h1>
              <p className="text-amber-700">Relax and color beautiful designs</p>
            </div>
            
            {/* Tool Bar */}
            <div className="bg-white rounded-2xl shadow-lg p-4 mb-4">
              <div className="flex flex-wrap items-center gap-4 justify-center">
                <div className="flex gap-2">
                  {['fill', 'brush', 'eraser', 'eyedropper'].map((m) => (
                    <button key={m} onClick={() => setMode(m)}
                      className={`flex items-center gap-1 px-4 py-2 rounded-lg transition-all text-sm ${
                        mode === m ? (m === 'eyedropper' ? 'bg-purple-500 text-white shadow-md' : 'bg-amber-500 text-white shadow-md')
                        : (m === 'eyedropper' ? 'bg-purple-50 text-purple-700 hover:bg-purple-100' : 'bg-amber-50 text-amber-700 hover:bg-amber-100')
                      }`}>
                      <Icon name={m === 'fill' ? 'Droplet' : m === 'brush' ? 'Paintbrush' : m === 'eraser' ? 'Eraser' : 'Pipette'} size={16} />
                      {m === 'fill' ? 'Fill' : m === 'brush' ? 'Brush' : m === 'eraser' ? 'Erase' : 'Pick Color'}
                    </button>
                  ))}
                </div>
                {(mode === 'brush' || mode === 'eraser') && (
                  <div className="w-36 flex items-center gap-2">
                    <span className="text-xs text-amber-700">Size:</span>
                    <input type="range" min={mode === 'brush' ? 5 : 10} max={mode === 'brush' ? 50 : 80}
                      value={mode === 'brush' ? brushSize : eraserSize}
                      onChange={(e) => mode === 'brush' ? setBrushSize(Number(e.target.value)) : setEraserSize(Number(e.target.value))}
                      className="flex-1 h-2" />
                    <span className="text-xs text-amber-700 w-8">{mode === 'brush' ? brushSize : eraserSize}px</span>
                  </div>
                )}
              </div>
            </div>
            
            <div className="grid md:grid-cols-[1fr,320px] gap-4">
              {/* Canvas */}
              <div className={`bg-white rounded-2xl shadow-lg p-4 relative ${isDragging ? 'ring-4 ring-indigo-400 ring-opacity-50' : ''}`}
                onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop}>
                {isDragging && (
                  <div className="absolute inset-0 bg-indigo-100 bg-opacity-90 rounded-2xl flex items-center justify-center z-10">
                    <div className="text-center">
                      <Icon name="Sparkles" size={48} className="mx-auto text-indigo-500 mb-2" />
                      <p className="text-xl font-semibold text-indigo-700">Drop image here</p>
                    </div>
                  </div>
                )}
                <div className="flex items-center justify-between mb-3">
                  <h3 className="font-semibold text-amber-900 truncate">{currentImageName}</h3>
                  <div className="text-sm text-amber-600 whitespace-nowrap ml-2">
                    {mode === 'fill' ? 'üé® Fill' : mode === 'brush' ? 'üñåÔ∏è Brush' : mode === 'eraser' ? 'üßπ Erase' : 'üíâ Pick'}
                  </div>
                </div>
                <canvas ref={canvasRef} width={700} height={600}
                  onClick={handleCanvasClick} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove}
                  onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
                  className="w-full border-2 border-amber-200 rounded-lg bg-white" style={{ cursor: 'crosshair' }} />
                {currentImageName === 'Generate or upload a coloring page' && (
                  <div className="absolute inset-0 flex items-center justify-center pointer-events-none" style={{top: '60px'}}>
                    <div className="text-center text-amber-400">
                      <p className="text-lg">Generate with AI or drag & drop an image</p>
                      <p className="text-sm">Use the panel on the right to get started</p>
                    </div>
                  </div>
                )}
              </div>
              
              {/* Side Panel */}
              <div className="bg-white rounded-2xl shadow-lg p-4 space-y-4 overflow-y-auto max-h-[800px]">
                
                {/* API Key Section */}
                <div className="pb-3 border-b border-amber-200">
                  <div className="flex items-center justify-between mb-2">
                    <h3 className="font-semibold text-amber-900 text-sm">üîë Gemini API Key</h3>
                    <button onClick={() => setShowApiKeyInput(!showApiKeyInput)} className="text-xs text-purple-600 hover:text-purple-800">
                      {apiKey ? '‚úì Key Set' : 'Set Key'}
                    </button>
                  </div>
                  
                  {showApiKeyInput && (
                    <div className="p-2 bg-purple-50 rounded-lg">
                      <input type="password" value={apiKeyTemp} onChange={(e) => setApiKeyTemp(e.target.value)}
                        placeholder="Enter your Gemini API key..."
                        className="w-full p-2 border-2 border-purple-200 rounded-lg text-xs focus:outline-none focus:border-purple-400" />
                      <div className="flex gap-2 mt-2">
                        <button onClick={saveApiKey} className="flex-1 bg-purple-500 text-white text-xs p-1.5 rounded hover:bg-purple-600">Save</button>
                        {apiKey && <button onClick={clearApiKey} className="bg-red-100 text-red-600 text-xs p-1.5 rounded hover:bg-red-200">Clear</button>}
                      </div>
                      <p className="text-xs text-purple-500 mt-2">
                        Get your free key at <a href="https://aistudio.google.com/app/apikey" target="_blank" className="underline">Google AI Studio</a>
                      </p>
                    </div>
                  )}
                  
                  {!showApiKeyInput && !apiKey && (
                    <p className="text-xs text-amber-600">Set your API key to use AI features</p>
                  )}
                </div>
                
                {/* AI Image Generation */}
                <div className="pb-3 border-b border-amber-200">
                  <h3 className="font-semibold text-amber-900 text-sm mb-2">‚ú® AI Generate Coloring Page</h3>
                  <input
                    type="text"
                    value={imagePrompt}
                    onChange={(e) => setImagePrompt(e.target.value)}
                    placeholder="e.g., a cute cat playing with yarn"
                    className="w-full p-2 border-2 border-amber-200 rounded-lg text-sm focus:outline-none focus:border-amber-400"
                    onKeyPress={(e) => e.key === 'Enter' && generateColoringPage()}
                    disabled={isGeneratingImage}
                  />
                  <button
                    onClick={generateColoringPage}
                    disabled={!imagePrompt.trim() || isGeneratingImage}
                    className={`w-full mt-2 flex items-center justify-center gap-2 p-2 rounded-lg transition-all text-sm ${
                      !imagePrompt.trim() || isGeneratingImage
                        ? 'bg-gray-200 text-gray-400 cursor-not-allowed'
                        : 'bg-gradient-to-r from-pink-500 to-orange-500 text-white hover:from-pink-600 hover:to-orange-600'
                    }`}
                  >
                    <Icon name="Wand2" size={16} />
                    {isGeneratingImage ? 'Generating...' : 'Generate Coloring Page'}
                  </button>
                  {imageError && <p className="mt-2 text-xs text-red-500">{imageError}</p>}
                </div>
                
                {/* Upload Section */}
                <div className="pb-3 border-b border-amber-200">
                  <h3 className="font-semibold text-amber-900 mb-2 text-sm">üìÅ Or Upload Image</h3>
                  <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/*" className="hidden" />
                  <button onClick={() => fileInputRef.current?.click()}
                    className="w-full flex items-center justify-center gap-2 p-2 rounded-lg bg-indigo-500 text-white hover:bg-indigo-600 text-sm">
                    <Icon name="Upload" size={16} /> Upload Image
                  </button>
                </div>
                
                {/* Color Picker */}
                <div className="space-y-3 pb-3 border-b border-amber-200">
                  <h3 className="font-semibold text-amber-900 text-sm">üé® Color Picker</h3>
                  <div className="flex items-center gap-3 justify-center">
                    <canvas ref={colorWheelRef} width={200} height={200} onClick={handleColorWheelClick}
                      className="w-20 h-20 cursor-pointer rounded-lg border-2 border-amber-200" />
                    <div className="flex flex-col items-center">
                      <div className="w-14 h-14 rounded-lg border-2 border-amber-300 shadow-inner" style={{ backgroundColor: currentColor }} />
                      <div className="mt-1 text-xs font-mono text-amber-700">{currentColor}</div>
                    </div>
                  </div>
                  <div className="space-y-2">
                    {[['Hue', hue, setHue, 360, `linear-gradient(to right, hsl(0,100%,50%), hsl(60,100%,50%), hsl(120,100%,50%), hsl(180,100%,50%), hsl(240,100%,50%), hsl(300,100%,50%), hsl(360,100%,50%))`],
                      ['Saturation', saturation, setSaturation, 100, null],
                      ['Lightness', lightness, setLightness, 100, null]].map(([label, val, setVal, max, bg]) => (
                      <div key={label}>
                        <div className="flex justify-between text-xs text-amber-700 mb-1">
                          <span>{label}</span><span>{val}{label === 'Hue' ? '¬∞' : '%'}</span>
                        </div>
                        <input type="range" min="0" max={max} value={val} onChange={(e) => setVal(Number(e.target.value))}
                          className="w-full h-2" style={bg ? { background: bg } : {}} />
                      </div>
                    ))}
                  </div>
                </div>
                
                {/* Recent Colors */}
                {recentColors.length > 0 && (
                  <div className="pb-3 border-b border-amber-200">
                    <h3 className="font-semibold text-amber-900 text-sm mb-2">Recent Colors</h3>
                    <div className="flex flex-wrap gap-2">
                      {recentColors.map((color, i) => (
                        <button key={i} onClick={() => selectColor(color)}
                          className="w-8 h-8 rounded-lg border-2 border-amber-300 hover:scale-110 transition-transform shadow-sm"
                          style={{ backgroundColor: color }} title={color} />
                      ))}
                    </div>
                  </div>
                )}
                
                {/* AI Color Suggestions */}
                <div className="pb-3 border-b border-amber-200">
                  <h3 className="font-semibold text-amber-900 text-sm mb-2">‚ú® AI Color Suggestions</h3>
                  <input type="text" value={colorPrompt} onChange={(e) => setColorPrompt(e.target.value)}
                    placeholder="e.g., sunset beach, forest..."
                    className="w-full p-2 border-2 border-amber-200 rounded-lg text-sm focus:outline-none focus:border-amber-400"
                    onKeyPress={(e) => e.key === 'Enter' && suggestColors()} />
                  <button onClick={suggestColors} disabled={!colorPrompt.trim() || isLoadingColors}
                    className={`w-full mt-2 flex items-center justify-center gap-2 p-2 rounded-lg transition-all text-sm ${
                      !colorPrompt.trim() || isLoadingColors ? 'bg-gray-200 text-gray-400 cursor-not-allowed'
                      : 'bg-gradient-to-r from-purple-500 to-pink-500 text-white hover:from-purple-600 hover:to-pink-600'
                    }`}>
                    <Icon name="Sparkles" size={16} />
                    {isLoadingColors ? 'Getting colors...' : 'Suggest Colors'}
                  </button>
                  {colorError && <p className="mt-2 text-xs text-red-500">{colorError}</p>}
                  
                  {suggestedColors.length > 0 && (
                    <div className="mt-3 grid grid-cols-4 gap-2">
                      {suggestedColors.map((color, i) => (
                        <button key={i} onClick={() => selectColor(color.hex)} className="flex flex-col items-center p-1 rounded-lg hover:bg-amber-50" title={color.name}>
                          <div className="w-10 h-10 rounded-lg border-2 border-amber-300 shadow-sm hover:scale-105 transition-transform" style={{ backgroundColor: color.hex }} />
                          <span className="text-xs text-amber-600 mt-1 truncate w-full text-center">{color.name.split(' ')[0]}</span>
                        </button>
                      ))}
                    </div>
                  )}
                </div>
                
                {/* Actions */}
                <div className="space-y-2">
                  <button onClick={undo} disabled={history.length <= 1}
                    className={`w-full flex items-center justify-center gap-2 p-2 rounded-lg text-sm ${history.length <= 1 ? 'bg-gray-200 text-gray-400' : 'bg-blue-500 text-white hover:bg-blue-600'}`}>
                    <Icon name="Undo2" size={16} /> Undo ({history.length - 1})
                  </button>
                  <button onClick={resetCanvas} className="w-full flex items-center justify-center gap-2 bg-amber-500 text-white p-2 rounded-lg hover:bg-amber-600 text-sm">
                    <Icon name="RotateCcw" size={16} /> Reset Colors
                  </button>
                  <button onClick={downloadImage} className="w-full flex items-center justify-center gap-2 bg-emerald-500 text-white p-2 rounded-lg hover:bg-emerald-600 text-sm">
                    <Icon name="Download" size={16} /> Download
                  </button>
                </div>

                <div className="text-xs text-amber-600 text-center pt-2">
                  <strong>Fill:</strong> Click ‚Ä¢ <strong>Brush:</strong> Paint ‚Ä¢ <strong>Erase:</strong> Remove ‚Ä¢ <strong>Pick:</strong> Sample
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<CozyColoringApp />);
  </script>
</body>
</html>
